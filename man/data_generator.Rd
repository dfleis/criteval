% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data_generator.R
\name{data_generator}
\alias{data_generator}
\title{Create a data generator factory}
\usage{
data_generator(
  kappa.ratio,
  rho.W = NULL,
  R.W = NULL,
  q.W = 1,
  mu.W = NULL,
  p.X = 1,
  rho.X = 0,
  sigma.eps = 1,
  theta_FUN_list,
  nu_FUN,
  ...
)
}
\arguments{
\item{kappa.ratio}{The target condition number ratio, must be \code{kappa.ratio >= 1}.}

\item{rho.W}{The AR(1) correlation parameter for the \code{W} regressors. See \code{rho} in \code{\link[=generate_corr]{generate_corr()}}.
Ignored if a correlation matrix \code{R.W} is provided.}

\item{R.W}{An optional, pre-specified correlation matrix for \code{W}. See \code{R} in \code{\link[=generate_cov]{generate_cov()}}.}

\item{q.W}{The number of "strong" (high relative variance) features in \code{W}. See \code{q} in \code{\link[=generate_cov]{generate_cov()}}.}

\item{mu.W}{An optional mean vector for the regressors \code{W}. Defaults to a zero vector.}

\item{p.X}{The dimension of the auxiliary covariates \code{X}.}

\item{rho.X}{The AR(1) correlation for the latent Gaussian variables used to
generate the \code{X} covariates via a copula. Defaults to \code{rho.X = 0}, which
corresponds to independent Uniform(0,1) covariates.}

\item{sigma.eps}{The standard deviation of the Gaussian noise term epsilon.}

\item{theta_FUN_list}{A list of \eqn{K} functions, where each function takes the
\code{n}-by-\code{p.X} matrix \code{X} and returns an \code{n}-dimensional vector for one component
of \code{theta_FUN_list[[k]](X)}.}

\item{nu_FUN}{A function that takes an \code{n}-by-\code{p.X} matrix \code{X} and returns the
\code{n}-dimensional nuisance vector \code{nu_FUN(X)}.}

\item{...}{Additional arguments passed to \code{\link[=generate_cov]{generate_cov()}}.}
}
\value{
An object of class \code{criteval_generator}. This is a list containing
generator functions (\verb{$generate}, \verb{$X}, \verb{$W}) and key parameters (\verb{$Sigma},
\verb{$theta_FUN}, etc.) that define the DGP.
}
\description{
This function acts as a factory method to produce a data generator object.
It takes all the parameters that define a data-generating process (DGP) and
returns an object that can be used to repeatedly generate datasets from that
DGP.
}
\details{
The regressors \code{W} are sampled from a multivariate Gaussian whose covariance
structure is determined by the provided correlation structure (either through
the AR(1) correlation parameter \code{rho} or via an explicit correlation matrix \code{R})
as well as target condition number ratio \code{kappa.ratio}. The condition number
ratio is the ratio of the condition numbers for the desired covariance matrix
and generated/supplied correlation matrix.

The auxiliary covariates \code{X} are generated from a Gaussian copula with an
AR(1) correlation structure defined by \code{rho.X}. When \code{rho.X = 0} (the default),
the \code{X} covariates are independent Uniform(0,1).

This factory ensures reproducibility. Providing the same \code{seed} will yield
the same random components, as the main seed is used to derive a stable
set of component-specific seeds.
}
\examples{
\dontrun{
# Define the DGP parameters and create the generator
theta_funs <- list(
  theta1 = function(x) plogis((x[,1] - 0.45), scale = 1/10),
  theta2 = function(x) plogis(-(x[,1] - 0.55), scale = 1/10)
)
nu_fun <- function(x) { 0 * x[,1] }

gen <- data_generator(
  kappa.ratio = 1.5, # W: Target condition number ratio kappa(Sigma.W)/kappa(R.W)
  rho.W = 0.6,       # W: AR(1) correlation parameter for W
  q.W = 1,           # W: Number of relative high variance regressors W
  p.X = 2,           # X: Auxiliary covariate dimension p
  rho.X = 0.8,       # X: AR(1) correlation parameter for X
  sigma.eps = 0.1,   # Gaussian noise standard deviation
  nu_FUN = nu_fun,   # VCM intercept (nuisance function)
  theta_FUN_list = theta_funs # Underlying target effect functions
)

# Use the generator to create datasets
data <- gen$generate(n = 5, seed = 123)

# # Reproducible data
# data$X
# gen$X(n = 5, seed = 123)

# data$W
# gen$W(n = 5, seed = 123)
}

}
